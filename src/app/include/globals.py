# AppBackup
# An iPhoneOS application that backs up and restores the saved data and
# preferences of App Store apps.
#
# Copyright (C) 2008-2011 Scott Zeid
# http://me.srwz.us/iphone/appbackup
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
# 
# Except as contained in this notice, the name(s) of the above copyright holders
# shall not be used in advertising or otherwise to promote the sale, use or
# other dealings in this Software without prior written authorization.
#
# Loosely based on Dave Arter's (dave@minus-zero.org) sample code from the
# iPhone/Python package.

# Globals

### CLASSES ###

class FoundationPlist:
 """A class to work with binary or XML plists using the Foundation framework."""
 @classmethod
 def read(cls, filename):
  """Reads a binary or XML plist from the given file name and returns the resulting dictionary."""
  return NSDictionary.alloc().initWithContentsOfFile_(filename)
 @classmethod
 def write(cls, dictionary, filename):
  """Writes a dictionary to an XML plist at filename."""
  spam = NSDictionary.alloc().initWithDictionary_(dictionary)
  spam.writeToFile_atomically_(filename, NO)

### FUNCTIONS ###

def act_on_app(app, index, action):
 """Backs up or restores a given app.

app is a dictionary from shared.apps (generated by find_apps/find_apps_old) that
describes an app.  index is the index of the app in self.apps (but appears to
not be used), and action is one of "Backup", "Restore", or "Delete"
(case-insensitive and not localized).

action == "Backup" backs up the app and returns the time it was finished.
action == "Restore" restores the app and returns True if the backup exists;
False otherwise.
action == "Delete" deletes the BACKUP and returns True if successful; False
otherwise.

"""
 if app["useable"] == False:
  log('app["useable"] is False; aborting.')
  return False
 path = str(app["path"])
 bundle = str(app["bundle"])
 tarpath = str("%s/%s.tar.gz" % (shared.tarballs, bundle))
 logtext = '"' + app["friendly"] + "\" (%s, %s, %s)..." % (bundle, path, tarpath)
 try:
  if action.lower() == "backup":  # Internal string; don't translate
   log("Backing up " + escape_utf8(logtext))
   if os.path.exists(tarpath) != True:
    log("Creating archive...")
    f = open(tarpath, "w")
    f.close()
   log("Opening archive...")
   tar = tarfile.open(tarpath, "w:gz")
   log("Archiving path/Documents...")
   tar.add(path+"/Documents", arcname="Documents")
   log("Archiving path/Library...")
   tar.add(path+"/Library", arcname="Library")
   log("Closing tarball...")
   tar.close()
   now = str(time.mktime(time.localtime()))
   log("Finished backup at " + now)
   return now
  elif action.lower() == "restore":  # Internal string; don't translate
   log("Restoring " + escape_utf8(logtext))
   if os.path.exists(tarpath) == True:
    log("Opening archive...")
    tar = tarfile.open(tarpath)
    log("Extracting...")
    tar.extractall(path)
    log("Closing archive...")
    tar.close()
    log("Finished restore at " + str(time.mktime(time.localtime())))
    return True
  elif action.lower() == "delete":  # Internal string; don't translate
   log("Deleting backup of " + escape_utf8(logtext))
   if os.path.exists(tarpath) == True:
    os.remove(tarpath)
    log("Finished deletion at " + str(time.mktime(time.localtime())))
    return True
  else:
   log(action + " is not a valid action")
   return False
 except (IOError, OSError, tarfile.TarError):
  log(traceback.format_exc())
 log("Could not %s %s.  Asking Congress for a bailout..." % (action.lower(), tarpath))
 return False

def escape_utf8(s):
 """Escapes UTF-8 characters; there's probably a much simpler way of doing this."""
 r = s.encode('utf8', 'replace').__repr__()
 if len(r) >= 2:
  if r[0] == "'" and r[-1] == "'":
   return r[1:-1]
  if r[0] == '"' and r[-1] == '"':
   return r[1:-1]
 return r

# find_apps and find_apps_using_mic are defined at the bottom of this file
# because they're very long.

def iterate_backups():
 shared.all_bak = True; shared.any_bak = False
 for i in shared.apps:
  if i["bundle"] in shared.times and i["bundle"] not in shared.ignore:
   shared.any_bak = True
  else:
   shared.all_bak = False

def localized_date(d):
 """Returns a localized date string.

Takes a UNIX timestamp and makes it a string formatted according to the device's
locale and user preferences.  If this fails for some reason, falls back to the
format MMM DD, YYYY hh:mm:ss AM/PM.

"""
 date = time.strftime("%Y-%m-%d %H:%M:%S", d)
 dateformat = NSDateFormatter.alloc().init()
 dateformat.setDateFormat_("yyyy-MM-dd HH:mm:ss")
 date2 = dateformat.dateFromString_(date)
 dateformat2 = NSDateFormatter.alloc().init()
 dateformat2.setDateStyle_(2)
 dateformat2.setTimeStyle_(1)
 out = dateformat2.stringFromDate_(date2)
 if out == None:
  out = time.strftime("%b %d, %Y %I:%M:%S %p", d)
 return out

def log(text, newline=True):
 """Prints debugging text to stdout."""
 entry = "%s[%#.3f]: %s" % (shared.name, round(time.time() - __starttime__, 3), text)
 entry = escape_utf8(entry)
 if newline:
  entry += "\n"
 sys.stdout.write(entry)
 sys.stdout.flush()

def save_backuptimes_plist(init=False):
 """Writes the backup times to ~mobile/Library/AppBackup/backuptimes.plist."""
 if init == True:
  thedict = {}
 else:
  thedict = shared.times
 FoundationPlist.write(thedict, shared.backuptimesfile)

def save_ignore_list(init=False):
 """Writes the ignore list to ~mobile/Library/AppBackup/ignore.txt"""
 if init == True:
  data = ""
 else:
  data = "\n".join(shared.ignore)
 with open(shared.ignorefile, "w") as f:
  f.write(data)

def string(s):
 """Gets a localizable string from LANGUAGE.lproj/Localizable.strings."""
 return unicode(NSBundle.mainBundle().localizedStringForKey_value_table_(s, "", None))

def strip_latin_diacritics(string):
 """Strip diacritical marks from Latin letters.

Replaces Latin letters with diacritical marks with the same letters without
diacritics, preserving case.  Input must be in Unicode.

Letter to diacritical mark mappings are found in include/latin_diacritics.py
and sourced from Wikipedia.

"""
 ret = string
 for letter in shared.latin_diacritics:
  for i in shared.latin_diacritics[letter]:
   ret = ret.replace(i, letter)
 return ret

def thread(function, args = [], kwargs = {}):
 """Call a callable object in a separate thread.

Passes a given function, positional arguments, and keyword arguments to the
_thread_meta private function defined below in a separate thread and returns the
thread.

"""
 t = threading.Thread(
  target=_thread_meta,
  args=[function],
  kwargs={"args": args, "kwargs": kwargs}
 )
 t.start()
 return t

def _thread_meta(function, args = [], kwargs = {}):
 # calls a given function with positional arguments args and keyword arguments
 # kwargs, and prints a traceback and interrupt the main thread if something
 # goes wrong.  Also sets up an NSAutoreleasePool for the thread.
 # AutoreleasePool code found in Obj-C by arekkusu at <http://bit.ly/9V2NwT>.
 try:
  autoreleasepool = NSAutoreleasePool.alloc().init();
  function(*args, **kwargs)
  autoreleasepool.release();
 except:
  sys.stdout.write("AppBackup: Exception in thread:\n")
  sys.stdout.write(traceback.format_exc() + "\n")
  sys.stdout.write("AppBackup: Exiting...\n")
  sys.stdin.close()
  sys.stdout.flush()
  sys.stderr.flush()
  sys.stdout.close()
  sys.stderr.close()
  atexit._run_exitfuncs()
  os._exit(127)

def toggle_ignore(index=None, state=None, iterate=True, iterateOnly=False):
 """Toggles the ignore key for a given app at shared.apps[index].

If state is not None, then the ignore key is set to state, which should be True
or False in this case.

If iterate is True (default), we also make sure all apps have backups and set
shared.all_bak to False if they don't.  If iterateOnly is True, then this is the
only thing we do.

ignore.txt will also be updated if iterateOnly is False.

"""
 if not iterateOnly:
  if index == None:
   return False
  bundle = shared.apps[index]["bundle"]
  if state not in (True, False):
   state = not shared.apps[index]["ignore"]
  if state:
   shared.ignore.append(bundle)
   shared.ignore.sort()
   shared.apps[index]["bak_text"] = string("baktext_ignored")
  else:
   shared.ignore.remove(bundle)
   shared.apps[index]["bak_text"] = shared.apps[index]["bak_text_real"]
  save_ignore_list()
  shared.apps[index]["ignore"] = state
 if iterate:
  iterate_backups()
 return True

def update_backup_time(index=None, backupTime=None, iterate=True, iterateOnly=False):
 """Updates the backup time for a given app at shared.apps[index].

If iterate is True (default), we also make sure all apps have backups and set
shared.all_bak to False if they don't.  If iterateOnly is True, then this is the
only thing we do.

backuptimes.plist will also be updated if iterateOnly is False.

"""
 if iterateOnly == False:
  if index == None:
   return False
  bundle = shared.apps[index]["bundle"]
  if backupTime:
   shared.times[bundle] = backupTime
   save_backuptimes_plist()
   baksec = time.localtime(float(backupTime))
   bak = localized_date(baksec)
   shared.apps[index]["bak"] = bak
   shared.apps[index]["bak_text"] = string("baktext_yes") % bak
   shared.apps[index]["bak_time"] = baksec
  else:
   del shared.times[bundle]
   save_backuptimes_plist()
   shared.apps[index]["bak"] = None
   shared.apps[index]["bak_text"] = string("baktext_no")
   shared.apps[index]["bak_time"] = None
  if shared.apps[index]["ignore"]:
   shared.apps[index]["bak_text"] = string("baktext_ignored")
  shared.apps[index]["bak_text_real"] = shared.apps[index]["bak_text"]
 if iterate:
  iterate_backups()
 return True

def find_apps(callback=None):
 """Finds all App Store apps installed on the iDevice.

Makes a list where each item is a dict representing a given app.  Afterward,
callback is called with no arguments if it is specified and not None.  This
function gets its info by manually looking at each App Store app's Info.plist
file.

Each dict has these elements:
 key:           Sort key.
 name:          The basename of the .app folder.
 bundle:        The app's bundle identifier or "invalid.appbackup.corrupted" if
                the bundle identifier is unreadable.
 path:          Path to the .app folder's parent directory.
 tarpath:       Path to the backup file or "" if CFBundleIdentifier is
                unreadable.
 guid:          GUID of app taken from the directory the .app folder is in.
 friendly:      Friendly name of app, usually CFBundleDisplayName.
 possessive:    Possessive form of friendly.
 bak:           Human-readable backup time or None if no backup.
 bak_text:      Text displayed in the app list for the backup time.
 bak_text_real: Backup time to display when an app is un-ignored.
 bak_time:      struct_time of the last backup or None if no backup.
 useable:       True if we can work with the app; False otherwise.
 ignore:        True if the app has been ignored by the user; False otherwise.

The name of the key is the friendly name, converted to lowercase, with
diacritics stripped using strip_latin_diacritics, an underscore, and the bundle
name.  Example:  facebook_com.facebook.Facebook

In effect, the list is sorted by friendly name, then by bundle ID.

This used to be called find_apps_old and make_app_dict.

"""
 mobile = u"/var/mobile"
 root = mobile+"/Applications"
 applist = []; appdict = {}; apps = []
 apps1 = os.listdir(root)
 for i in apps1:
  if os.path.isdir(root+"/"+i) == True:
   apps.append(i)
 shared.all_bak = True; shared.any_bak = False; shared.any_corrupted = False
 if shared.apps_probed == False:
  # Debug text; do not translate
  log("Here are the app bundles and Info.plist's I found:")
 for k in apps:
  appdir = root+"/"+k
  for j in os.listdir(appdir):
   if j.endswith(u".app"):
    plistfile = u"%s/%s/Info.plist" % (appdir, j)
    if shared.apps_probed == False:
     # More debug text
     log(u"%s:  %s" % (escape_utf8(j), escape_utf8(plistfile.split(root+"/", 1)[1])))
    if os.path.exists(plistfile) == True:
     pl = FoundationPlist.read(plistfile)
     bundle = pl["CFBundleIdentifier"]
     tarpath = str("%s/%s.tar.gz" % (shared.tarballs, bundle))
     if "CFBundleDisplayName" in pl:
      friendly = pl["CFBundleDisplayName"]
      if friendly == "":
       friendly = j.rsplit(u".app", 1)[0]
     else:
      friendly = j.rsplit(u".app", 1)[0]
     sortname = u"%s_%s" % (friendly.lower(), bundle)
     useable = True
     
     if bundle in shared.times:
      baksec = time.localtime(float(shared.times[bundle]))
      bak = localized_date(baksec)
      baktext = baktext_real = string("baktext_yes") % bak
      if bundle not in shared.ignore:
       shared.any_bak = True
     elif os.path.isfile(tarpath) or os.path.islink(tarpath):
      try:
       baksec = time.localtime(float(os.stat(tarpath).st_mtime))
      except (IOError, OSError):
       baksec = time.localtime(0)
      shared.times[bundle] = time.mktime(baksec)
      save_backuptimes_plist()
      bak = localized_date(baksec)
      baktext = baktext_real = string("baktext_yes") % bak
      shared.any_bak = True
     else:
      baksec = None
      bak = None
      baktext = baktext_real = string("baktext_no")
      shared.all_bak = False
     
     if bundle in shared.ignore:
      ignore = True
      baktext = string("baktext_ignored")
      shared.all_bak = False
     else:
      ignore = False
    else:
     shared.any_corrupted = True
     friendly = j.rsplit(u".app", 1)[0]
     bundle = "invalid.appbackup.corrupted"
     tarpath = ""
     sortname = u"%s_%s" % (friendly, bundle)
     baksec = None
     bak = None
     baktext = baktext_real = string("app_corrupted_list")
     useable = False
     ignore = False
    
    if shared.plural_last != "" and friendly[-1] == shared.plural_last:
     possessive = string("plural_possessive") % friendly
    else:
     possessive = string("singular_possessive") % friendly
    
    applist.append(sortname)
    appdict[sortname] = {
     "key": sortname,
     "name": j,
     "bundle": bundle,
     "path": appdir,
     "tarpath": tarpath,
     "guid": k,
     "friendly": friendly,
     "possessive": possessive,
     "bak": bak,
     "bak_text": baktext,
     "bak_text_real": baktext_real,
     "bak_time": baksec,
     "useable": useable,
     "ignore": ignore
    }
 log("Found all App Store apps; sorting...")
 applist.sort()
 log("done.  Now for the finishing touches...")
 shared.apps = []
 for i in applist:
  shared.apps.append(appdict[i])
 shared.apps_probed = True
 log("done.  Now, back to our regularly scheduled programming, ")
 log(callback.__repr__() + ".")
 if callback != None:
  callback()

def find_apps_using_mic(callback=None):
 """Finds all App Store apps installed on the iDevice.  (MobileInstallationCache\
 method)

Makes a list where each item is a dict representing a given app.  (See the
documentation for find_apps for details about the list and dicts.)  Finally,
callback is called with no arguments if it is specified and not None.

This function tries to get the info from the MobileInstallation cache, and falls
back to find_apps if that doesn't work.  This function is deprecated.

"""
 if not os.path.exists("/var/mobile/Library/Caches/com.apple.mobile.installation.plist"):
  log("MobileInstallation cache not found; reverting to old method of finding apps...")
  find_apps(callback=callback)
  return
 try:
  mobileInstallationCache = FoundationPlist.read("/var/mobile/Library/Caches/com.apple.mobile.installation.plist")
 except:
  log("Reading the MobileInstallation cache failed; reverting to old method of finding apps...")
  find_apps_old(callback=callback)
  return
 if "User" not in mobileInstallationCache:
  log("MobileInstallation cache doesn't have a User key; reverting to old method of finding apps...")
  find_apps_old(callback=callback)
  return
 appStoreApps = mobileInstallationCache["User"]
 applist = []; appdict = {}
 shared.all_bak = True; shared.any_bak = False; shared.any_corrupted = False
 if shared.apps_probed == False:
  # Debug text; do not translate
  log("Here are the app bundles I found:")
 for key in appStoreApps:
  i = appStoreApps[key]
  path = "/".join(i["Path"].rstrip("/").split("/")[:-1])
  if os.path.exists(path) and "CFBundleIdentifier" in i and i["CFBundleIdentifier"] != "":
   useable = True
   dotApp = i["Path"].rstrip("/").split("/")[-1]
   dotAppFull = path + "/" + dotApp
   if path.startswith("/private"):
    path = path.split("/private", 1)[1]
   guid = path.split("/")[-1]
   if shared.apps_probed == False:
    # More debug text
    log(unicode(escape_utf8(dotAppFull)))
   if "CFBundleDisplayName" in i:
    friendly = i["CFBundleDisplayName"]
    if friendly == "":
     friendly = dotApp.rsplit(u".app", 1)[0]
   else:
    friendly = dotApp.rsplit(u".app", 1)[0]
   bundle = i["CFBundleIdentifier"]
   tarpath = str("%s/%s.tar.gz" % (shared.tarballs, bundle))
   sortname = u"%s_%s" % (strip_latin_diacritics(friendly).lower(), bundle)
   if bundle in shared.times:
    baksec = time.localtime(float(shared.times[bundle]))
    bak = localized_date(baksec)
    baktext = baktext_real = string("baktext_yes") % bak
    shared.any_bak = True
   elif os.path.isfile(tarpath) or os.path.islink(tarpath):
    try:
     baksec = time.localtime(float(os.stat(tarpath).st_mtime))
    except (IOError, OSError):
     baksec = time.localtime(0)
    shared.times[bundle] = time.mktime(baksec)
    save_backuptimes_plist()
    bak = localized_date(baksec)
    baktext = baktext_real = string("baktext_yes") % bak
    if bundle not in shared.ignore:
     shared.any_bak = True
   else:
    baksec = None
    bak = None
    baktext = baktext_real = string("baktext_no")
    shared.all_bak = False
   
   if bundle in shared.ignore:
    ignore = True
    baktext = string("baktext_ignored")
    shared.all_bak = False
   else:
    ignore = False
  else:
   useable = False
   ignore = False
   shared.any_corrupted = True
   if "CFBundleDisplayName" in i:
    friendly = i["CFBundleDisplayName"]
    if friendly == "":
     friendly = dotApp.rsplit(u".app", 1)[0]
   else:
    friendly = dotApp.rsplit(u".app", 1)[0]
   if "CFBundleIdentifier" in i:
    bundle = i["CFBundleIdentifier"]
    tarpath = str("%s/%s.tar.gz" % (shared.tarballs, bundle))
   else:
    bundle = "invalid.appbackup.corrupted"
    tarpath = ""
   sortname = u"%s_%s" % (strip_latin_diacritics(friendly).lower(), bundle)
   baksec = None
   bak = None
   baktext = baktext_real = string("app_corrupted_list")
  
  if shared.plural_last != "" and friendly[-1] == shared.plural_last:
   possessive = string("plural_possessive") % friendly
  else:
   possessive = string("singular_possessive") % friendly
  
  applist.append(sortname)
  appdict[sortname] = {
   "key": sortname,
   "name": dotApp,
   "bundle": bundle,
   "path": path,
   "tarpath": tarpath,
   "guid": guid,
   "friendly": friendly,
   "possessive": possessive,
   "bak": bak,
   "bak_text": baktext,
   "bak_text_real": baktext_real,
   "bak_time": baksec,
   "useable": useable
  }
 log("Found all App Store apps; sorting...")
 applist.sort()
 log("done.  Now for the finishing touches...")
 shared.apps = []
 for i in applist:
  shared.apps.append(appdict[i])
 shared.apps_probed = True
 log("done.  Now, back to our regularly scheduled programming, ")
 log(callback.__repr__() + ".")
 if callback != None:
  callback()
