# AppBackup
# An iPhoneOS application that backs up and restores the saved data and
# preferences of App Store apps.
#
# Copyright (C) 2008-2010 Scott Wallace
# http://www.scott-wallace.net/iphone/appbackup
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
#
# Loosely based on Dave Arter's (dave@minus-zero.org) sample code from the
# iPhone/Python package.

# Globals

### CLASSES ###

class FoundationPlist:
 """A class to work with binary or XML plists using the Foundation framework."""
 @classmethod
 def read(cls, filename):
  """Reads a binary or XML plist from the given file name and returns the resulting dictionary."""
  return NSDictionary.alloc().initWithContentsOfFile_(filename)
 @classmethod
 def write(cls, dictionary, filename):
  """Writes a dictionary to an XML plist at filename."""
  spam = NSDictionary.alloc().initWithDictionary_(dictionary)
  spam.writeToFile_atomically_(filename, NO)

### FUNCTIONS ###

def act_on_app(app, index, action):
 """Backs up or restores a given app.

app is a dictionary from shared.apps (generated by find_apps/find_apps_old) that
describes an app.  index is the index of the app in self.apps (but appears to
not be used), and action is one of "Backup" or "Restore" (case-sensitive and not
localized).

action == "Backup" backs up the app and returns the time it was finished.
action == "Restore" restores the app and returns True if the backup exists;
False otherwise.

"""
 if app["useable"] == False:
  return False
 path = str(app["path"])
 bundle = str(app["bundle"])
 tarpath = str("%s/%s.tar.gz" % (shared.tarballs, bundle))
 logtext = '"' + app["friendly"] + "\" (%s, %s, %s)..." % (bundle, path, tarpath)
 if action == "Backup":  # Internal string; don't translate
  log("Backing up " + escape_utf8(logtext))
  if os.path.exists(tarpath) != True:
   log("Creating archive...")
   f = open(tarpath, "w")
   f.close()
  log("Opening archive...")
  tar = tarfile.open(tarpath, "w:gz")
  log("Archiving path/Documents...")
  tar.add(path+"/Documents", arcname="Documents")
  log("Archiving path/Library...")
  tar.add(path+"/Library", arcname="Library")
  log("Closing tarball...")
  tar.close()
  now = str(time.mktime(time.localtime()))
  log("Finished backup at " + now)
  return now
 if action == "Restore":  # Internal string; don't translate
  log("Restoring " + escape_utf8(logtext))
  if os.path.exists(tarpath) == True:
   log("Opening archive...")
   tar = tarfile.open(tarpath)
   log("Extracting...")
   tar.extractall(path)
   log("Closing archive...")
   tar.close()
   return True
  else:
   log("The file %s does not exist.  Asking Congress for a bailout..." % tarpath)
   return False

def escape_utf8(s):
 """Escapes UTF-8 characters; there's probably a much simpler way of doing this."""
 r = s.encode('utf8', 'replace').__repr__()
 if len(r) >= 2:
  if r[0] == "'" and r[-1] == "'":
   return r[1:-1]
  if r[0] == '"' and r[-1] == '"':
   return r[1:-1]
 return r

# find_apps and find_apps_old are defined at the bottom of this file because
# they're very long.

def localized_date(d):
 """Returns a localized date string.

Takes a UNIX timestamp and makes it a string formatted according to the device's
locale and user preferences.  If this fails for some reason, falls back to the
format MMM DD, YYYY hh:mm:ss AM/PM.

"""
 date = time.strftime("%Y-%m-%d %H:%M:%S", d)
 dateformat = NSDateFormatter.alloc().init()
 dateformat.setDateFormat_("yyyy-MM-dd HH:mm:ss")
 date2 = dateformat.dateFromString_(date)
 dateformat2 = NSDateFormatter.alloc().init()
 dateformat2.setDateStyle_(2)
 dateformat2.setTimeStyle_(1)
 out = dateformat2.stringFromDate_(date2)
 if out == None:
  out = time.strftime("%b %d, %Y %I:%M:%S %p", d)
 return out

def log(text, newline=True):
 """Prints debugging text to stdout."""
 entry = "AB[%#.3f] %s: %s" % (round(time.time() - __starttime__, 3), shared.name, text)
 entry = escape_utf8(entry)
 if newline:
  entry += "\n"
 sys.stdout.write(entry)
 sys.stdout.flush()

def save_backuptimes_plist(init=False):
 """Writes the backup times to ~mobile/Library/AppBackup/backuptimes.plist."""
 if init == True:
  thedict = {}
 else:
  thedict = shared.times
 FoundationPlist.write(thedict, shared.backuptimesfile)

def string(s):
 """Gets a localizable string from LANGUAGE.lproj/Localizable.strings."""
 return unicode(NSBundle.mainBundle().localizedStringForKey_value_table_(s, "", None))

def strip_latin_diacritics(string):
 """Strip diacritical marks from Latin letters.

Replaces Latin letters with diacritical marks with the same letters without
diacritics, preserving case.  Input must be in Unicode.

Letter to diacritical mark mappings are found in include/latin_diacritics.py
and sourced from Wikipedia.

"""
 ret = string
 for letter in shared.latin_diacritics:
  for i in shared.latin_diacritics[letter]:
   ret = ret.replace(i, letter)
 return ret

def thread(function, args = [], kwargs = {}):
 """Call a callable object in a separate thread.

Passes a given function, positional arguments, and keyword arguments to the
_thread_meta private function defined below in a separate thread and returns the
thread.

"""
 t = threading.Thread(
  target=_thread_meta,
  args=[function],
  kwargs={"args": args, "kwargs": kwargs}
 )
 t.start()
 return t

def _thread_meta(function, args = [], kwargs = {}):
 # calls a given function with positional arguments args and keyword arguments
 # kwargs, and prints a traceback and interrupt the main thread if something
 # goes wrong.  Also sets up an NSAutoreleasePool for the thread.
 # AutoreleasePool code found in Obj-C by arekkusu at <http://bit.ly/9V2NwT>.
 try:
  autoreleasepool = NSAutoreleasePool.alloc().init();
  function(*args, **kwargs)
  autoreleasepool.release();
 except:
  sys.stdout.write("AB:Exception in thread:\n")
  sys.stdout.write(traceback.format_exc() + "\n")
  sys.stdout.write("AB:Exiting...\n")
  sys.stdin.close()
  sys.stdout.flush()
  sys.stderr.flush()
  sys.stdout.close()
  sys.stderr.close()
  atexit._run_exitfuncs()
  os._exit(127)

def update_backup_time(index = None, backupTime = None, iterate = True, iterateOnly = False):
 """Updates the backup time for a given app at shared.apps[index].

If iterate is True (default), we also make sure all apps have backups and set
shared.all_bak to False if they don't.  If iterateOnly is True, then this is the
only thing we do.

backuptimes.plist will also be updated if iterateOnly is False.

"""
 if iterateOnly == False:
  if index == None or backupTime == None:
   return False
  bundle = shared.apps[index]["bundle"]
  shared.times[bundle] = backupTime
  save_backuptimes_plist()
  baksec = time.localtime(float(backupTime))
  bak = localized_date(baksec)
  shared.apps[index]["bak"] = bak
  shared.apps[index]["bak_text"] = string("baktext_yes") % bak
  shared.apps[index]["bak_time"] = baksec
 if iterate:
  shared.any_bak = True; shared.all_bak = True
  for i in shared.apps:
   if i["bundle"] not in shared.times:
    shared.all_bak = False

def find_apps(callback=None):
 """Finds all App Store apps installed on the iDevice.

Makes a list where each item is a dict representing a given app.  Afterward,
callback is called with no arguments if it is specified and not None.

Each dict has the name of a .app folder, a bundle ID (e.g. com.spam.app), the
path to the .app folder's parent directory, the app's GUID, the display name of
the app, the possessive form of the display name, the time of the last backup as
a string, the text to display in the table that tells you when/if it was backed
up, and whether the app is useable (not corrupted) or not.  It tries to get the
info from the MobileInstallation cache, and falls back to find_apps_old if that
doesn't work.

The list is sorted by friendly name, then by bundle ID.

"""
 if not os.path.exists("/var/mobile/Library/Caches/com.apple.mobile.installation.plist"):
  log("MobileInstallation cache not found; reverting to old method of finding apps...")
  find_apps_old(callback=callback)
  return
 try:
  mobileInstallationCache = FoundationPlist.read("/var/mobile/Library/Caches/com.apple.mobile.installation.plist")
 except:
  log("Reading the MobileInstallation cache failed; reverting to old method of finding apps...")
  find_apps_old(callback=callback)
  return
 if "User" not in mobileInstallationCache:
  log("MobileInstallation cache doesn't have a User key; reverting to old method of finding apps...")
  find_apps_old(callback=callback)
  return
 appStoreApps = mobileInstallationCache["User"]
 applist = []; appdict = {}
 shared.all_bak = True; shared.any_bak = False; shared.any_corrupted = False
 if shared.apps_probed == False:
  # Debug text; do not translate
  log("Here are the app bundles I found:")
 for key in appStoreApps:
  i = appStoreApps[key]
  path = "/".join(i["Path"].rstrip("/").split("/")[:-1])
  if os.path.exists(path) and "CFBundleIdentifier" in i and i["CFBundleIdentifier"] != "":
   useable = True
   dotApp = i["Path"].rstrip("/").split("/")[-1]
   dotAppFull = path + "/" + dotApp
   if path.startswith("/private"):
    path = path.split("/private", 1)[1]
   guid = path.split("/")[-1]
   if shared.apps_probed == False:
    # More debug text
    log(unicode(escape_utf8(dotAppFull)))
   if "CFBundleDisplayName" in i:
    friendly = i["CFBundleDisplayName"]
    if friendly == "":
     friendly = dotApp.rsplit(u".app", 1)[0]
   else:
    friendly = dotApp.rsplit(u".app", 1)[0]
   bundle = i["CFBundleIdentifier"]
   sortname = u"%s_%s" % (strip_latin_diacritics(friendly).lower(), bundle)
   if bundle in shared.times:
    baksec = time.localtime(float(shared.times[bundle]))
    bak = localized_date(baksec)
    baktext = string("baktext_yes") % bak
    shared.any_bak = True
   else:
    baksec = None
    bak = None
    baktext = string("baktext_no")
    shared.all_bak = False
  else:
   useable = False
   shared.any_corrupted = True
   if "CFBundleDisplayName" in i:
    friendly = i["CFBundleDisplayName"]
    if friendly == "":
     friendly = dotApp.rsplit(u".app", 1)[0]
   else:
    friendly = dotApp.rsplit(u".app", 1)[0]
   if "CFBundleIdentifier" in i:
    bundle = i["CFBundleIdentifier"]
   else:
    bundle = "invalid.appbackup.corrupted"
   sortname = u"%s_%s" % (strip_latin_diacritics(friendly).lower(), bundle)
   baksec = None
   bak = None
   baktext = string("app_corrupted_list")
  
  if shared.plural_last != "" and friendly[-1] == shared.plural_last:
   possessive = string("plural_possessive") % friendly
  else:
   possessive = string("singular_possessive") % friendly
  
  applist.append(sortname)
  appdict[sortname] = {
   "key": sortname,
   "name": dotApp,
   "bundle": bundle,
   "path": path,
   "guid": guid,
   "friendly": friendly,
   "possessive": possessive,
   "bak": bak,
   "bak_text": baktext,
   "bak_time": baksec,
   "useable": useable
  }
 log("Found all App Store apps; sorting...")
 applist.sort()
 log("done.  Now for the finishing touches...")
 shared.apps = []
 for i in applist:
  shared.apps.append(appdict[i])
 shared.apps_probed = True
 log("done.  Now, back to our regularly scheduled programming, ")
 log(callback.__repr__() + ".")
 if callback != None:
  callback()

def find_apps_old(callback=None):
 """Finds all App Store apps installed on the iDevice.  (Old method)

Makes a list where each item is a dict representing a given app.  (See the
documentation for find_apps for what data the dict has.)  Finally, callback is
called with no arguments if it is specified and not None.

This function gets its info by manually looking at each App Store app's
Info.plist file.  It has been superseded by find_apps and is kept around in case
the new find_apps fails to load the MobileInstallationCache file.  This used to
be called make_app_dict.

The list is sorted by friendly name, then by bundle ID.

"""
 mobile = u"/var/mobile"
 root = mobile+"/Applications"
 applist = []; applist1 = []; appdict = {}; apps = []
 apps1 = os.listdir(root)
 for i in apps1:
  if os.path.isdir(root+"/"+i) == True:
   apps.append(i)
 shared.all_bak = True; shared.any_bak = False; shared.any_corrupted = False
 if shared.apps_probed == False:
  # Debug text; do not translate
  log("Here are the app bundles and Info.plist's I found:")
 for k in apps:
  appdir = root+"/"+k
  for j in os.listdir(appdir):
   if j.endswith(u".app"):
    plistfile = u"%s/%s/Info.plist" % (appdir, j)
    if shared.apps_probed == False:
     # More debug text
     log(u"%s:  %s" % (escape_utf8(j), escape_utf8(plistfile.split(root+"/", 1)[1])))
    if os.path.exists(plistfile) == True:
     pl = FoundationPlist.read(plistfile)
     bundle = pl["CFBundleIdentifier"]
     if "CFBundleDisplayName" in pl:
      friendly = pl["CFBundleDisplayName"]
      if friendly == "":
       friendly = j.rsplit(u".app", 1)[0]
     else:
      friendly = j.rsplit(u".app", 1)[0]
     sortname = u"%s_%s" % (friendly.lower(), bundle)
     useable = True
     
     if bundle in shared.times:
      baksec = time.localtime(float(shared.times[bundle]))
      bak = localized_date(baksec)
      baktext = string("baktext_yes") % bak
      shared.any_bak = True
     else:
      baksec = None
      bak = None
      baktext = string("baktext_no")
      shared.all_bak = False
    else:
     shared.any_corrupted = True
     friendly = j.rsplit(u".app", 1)[0]
     bundle = "invalid.appbackup.corrupted"
     sortname = u"%s_%s" % (friendly, bundle)
     baksec = None
     bak = None
     baktext = string("app_corrupted_list")
     useable = False
    
    if shared.plural_last != "" and friendly[-1] == shared.plural_last:
     possessive = string("plural_possessive") % friendly
    else:
     possessive = string("singular_possessive") % friendly
    
    applist1.append(sortname)
    appdict[sortname] = {
     "key": sortname,
     "name": j,
     "bundle": bundle,
     "path": appdir,
     "guid": k,
     "friendly": friendly,
     "possessive": possessive,
     "bak": bak,
     "bak_text": baktext,
     "bak_time": bacsec,
     "useable": useable
    }
 log("Found all App Store apps; sorting...")
 # wait for uca_init to finish
 while shared.ucaInitThread.isAlive():
  time.sleep(0.125)
 applist1.sort(key=shared.ucaCollator.sort_key)
 log("done.  Now for the finishing touches...")
 for i in applist1:
  applist.append(appdict[i])
 shared.apps = applist
 shared.apps_probed = True
 log("done.  Now, back to our regularly scheduled programming, ")
 log(callback.__repr__() + ".")
 if callback != None:
  callback()
